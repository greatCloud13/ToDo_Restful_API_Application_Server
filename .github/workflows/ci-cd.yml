name: Todo web application API prj CI/CD with Docker

#언제 실행하는지 설정 (트리거 설정)
on:
  push:
    branches: [develop, main]
   # 개발 브랜치는 핵심이기에 항상 검증 시행
  pull_request:
    branches: [main]
    # main으로 들어오는 모든 PR은 반드시 검증 후 merge

jobs:
  #CI/CD 작업 정의 (테스트+빌드+Docker 배포)
  test:
    runs-on: ubuntu-latest #무료, 빠르고 안정적이므로 선정

    steps:
      # LEV 1. 소스코드 가져오기
      - name: Code checkout
        uses: actions/checkout@v4
        # GitHub 저장소의 코드를 CI 환경으로 다운로드

      # LEV 2. Java 환경 설정
      - name: SET JDK 22
        uses: actions/setup-java@v4
        with:
          java-version: '22'
          distribution: 'temurin' #안정적인 OpenJDK
          cache: 'gradle' #Gradle 의존성 자동 캐싱

      # LEV 3. 실행 권한 설정
      - name: Gradle run permission set
        run: chmod +x ./gradlew
        #리눅스 환경에서 gradlew 스크립트 실행 권한 부여

      # LEV 4. 테스트 실행 (품질 검증 - 제일 중요!)
      - name: Test Run
        run: ./gradlew test --info
        env:
          SPRING_PROFILES_ACTIVE: test # 테스트 전용 설정 사용
        # 코드 품질 보장, 버그 조기 발견

      # LEV 5. 애플리케이션 빌드 (테스트 통과 후)
      - name: Application Build
        run: ./gradlew build -x test
        # 실제 배포 가능한 JAR 파일 생성

      # LEV 6. Docker 빌드 환경 설정
      - name: Docker Buildx setup
        uses: docker/setup-buildx-action@v3
        # Docker의 고급 빌드 기능 활성화 (멀티 플랫폼, 캐싱 등)

      # LEV 7. Docker Hub 로그인
      - name: Docker Hub Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          # GitHub Secrets에 저장된 Docker Hub 인증 정보 사용

      # LEV 8. Docker 이미지 빌드 및 배포
      - name: Docker Image Build & Push
        uses: docker/build-push-action@v5
        with:
          context: . # 현재 디렉토리를 빌드 컨텍스트로 사용
          push: true #빌드 후 Docker Hub에 자동 푸시
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/spring-boot-app:latest
            ${{ secrets.DOCKER_USERNAME }}/spring-boot-app:${{ github.sha }}
          # latest 태그와 git commit hash 태그 동시 생성
          cache-from: type=gha # GitHub Actions 캐시에서 읽기
          cache-to: type=gha,mode=max # GitHub Actions 캐시에 저장
          # Docker 레이어 캐싱으로 빌드 시간 단축

      # LEV 9. AWS EC2 자동 배포
      - name: AWS ECS Auto Deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            # 기존 컨테이너 중지 및 제거
            /usr/local/bin/docker-compose down || true
            sudo docker container prune -f
            
            # nginx.conf 파일 생성 (없으면)
            if [ ! -f ~/nginx.conf ]; then
              cat > ~/nginx.conf << 'NGINX_EOF'
            events {
                worker_connections 1024;
            }
            
            http {
                include /etc/nginx/mime.types;
                default_type application/octet-stream;
            
                gzip on;
                gzip_vary on;
                gzip_min_length 1024;
                gzip_types text/plain text/css text/xml text/javascript application/javascript application/json application/xml+rss;
            
                server {
                    listen 80;
                    server_name _;
            
                    location / {
                        root /usr/share/nginx/html;
                        try_files $uri $uri/ /index.html;
                        add_header Cache-Control "no-cache";
                    }
            
                    location /api/ {
                        proxy_pass http://app:8080;
                        proxy_http_version 1.1;
                        proxy_set_header Host $host;
                        proxy_set_header X-Real-IP $remote_addr;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto $scheme;
                    }
            
                    location /todos/ {
                        proxy_pass http://app:8080;
                        proxy_http_version 1.1;
                        proxy_set_header Host $host;
                    }
            
                    location /dashboard/ {
                        proxy_pass http://app:8080;
                        proxy_http_version 1.1;
                        proxy_set_header Host $host;
                    }
            
                    location /calendar/ {
                        proxy_pass http://app:8080;
                        proxy_http_version 1.1;
                        proxy_set_header Host $host;
                    }
            
                    location /analytics/ {
                        proxy_pass http://app:8080;
                        proxy_http_version 1.1;
                        proxy_set_header Host $host;
                    }
                }
            }
            NGINX_EOF
            fi
            
            # react-build 디렉토리 생성 (없으면)
            mkdir -p ~/react-build
            if [ ! -f ~/react-build/index.html ]; then
              echo "<h1>Frontend deployment in progress...</h1>" > ~/react-build/index.html
            fi
            
            # docker-compose.yml 파일 생성 (nginx 포함)
            cat > docker-compose.yml << 'EOF'
            services:
              app:
                image: ${{ secrets.DOCKER_USERNAME }}/spring-boot-app:latest
                container_name: spring-app
                ports:
                  - "8080:8080"
                depends_on:
                  - mysql
                environment:
                  - SPRING_PROFILES_ACTIVE=docker
                restart: unless-stopped
                networks:
                  - app-network
            
              mysql:
                image: mysql:8.0
                container_name: mysql-db
                environment:
                  MYSQL_DATABASE: springdb
                  MYSQL_USER: springuser
                  MYSQL_PASSWORD: p@ss
                  MYSQL_ROOT_PASSWORD: rootpassword
                ports:
                  - "3306:3306"
                volumes:
                  - mysql_data:/var/lib/mysql
                restart: unless-stopped
                networks:
                  - app-network
            
              nginx:
                image: nginx:alpine
                container_name: nginx-server
                ports:
                  - "80:80"
                depends_on:
                  - app
                volumes:
                  - ./nginx.conf:/etc/nginx/nginx.conf:ro
                  - ./react-build:/usr/share/nginx/html:ro
                restart: unless-stopped
                networks:
                  - app-network
            
            volumes:
              mysql_data:
            
            networks:
              app-network:
                driver: bridge
            EOF
            
            # 새 이미지 다운로드 및 실행
            sudo docker compose pull app
            sudo docker compose up -d
            
            # 배포 상태 확인
            sleep 15
            sudo docker compose ps
            

      # LEV 9. 테스트 결과 저장 (디버깅용)
      - name: Test result save
        uses: actions/upload-artifact@v4
        if: always() # 성공/실패 관계없이 항상 업로드
        with:
          name: test-results
          path: build/reports/tests/test/
          # 테스트 실패 시 어떤 테스트가 실패했는지 분석 가능

      # LEV 10. 배포 완료 알림
      - name: Deployment Status
        run: |
          echo "CI/CD Pipeline Success!"
          echo "Docker image: ${{ secrets.DOCKER_USERNAME }}/spring-boot-app:latest"
          echo "Deployed to: http://${{ secrets.EC2_HOST }}:8080"
          echo "Health Check: http://${{ secrets.EC2_HOST }}:8080/actuator/health"